	list p=16f887
	include <p16f887.inc>

	extern LCD_bufer, bufer_count
	global LCD_Data_Recognize
	global seg1_1,seg1_2,seg1_3,seg1_4,seg1_5
	global seg2_1,seg2_2,seg2_3,seg2_4,seg2_5
	global seg3_1,seg3_2,seg3_3,seg3_4,seg3_5,seg3_6
	global koma

	udata
;ASCII_data res .16 ;распознанные данные в виде ASCII кода (поочередно – 
;сначала 1я строка 5 символов, потом 2я строка 5 символов, потом 3я строка 6 символов
;для удобства разбито на сегменты (разряды дисплея)
seg1_1		res .1 ;1я строка
seg1_2		res .1
seg1_3		res .1
seg1_4		res .1
seg1_5 		res .1 
seg2_1 		res .1 ;2я строка
seg2_2 		res .1
seg2_3 		res .1
seg2_4 		res .1
seg2_5 		res .1 
seg3_1 		res .1 ;3я строка
seg3_2 		res .1
seg3_3 		res .1
seg3_4 		res .1
seg3_5 		res .1
seg3_6 		res .1 
koma 		res .2 ;2 байта с позициями запятых
;- Распознать и преобразовать в ASCII код считанные данные
;LCD_Data_Recognize(LCD_bufer, ASCII_data)
;LCD_bufer - адрес ячейки начиная с которой располагается буфер считанных с весов данных 
;ASCII_data – распознанные данные в виде ASCII кода (поочередно – сначала 1я строка 5 символов, потом 2я строка 5 символов, потом 3я строка 6 символов, 2 байта с позициями запятых)
	code
LCD_Data_Recognize
;процедура распознавания символов
	;коды записи могут быть 137 бит - когда пишем всю память
	;или по 3+6+4*n (n=1..32) но скорее всего 3+6+8*n (n=1..16)
	;то есть ряд длин 17,25,33,41,49,57,65,73,81,89,97,105,113,121,129,137
	;остальные длины пакетов следует рассматривать как ошибочные
	;3 бита код 101, 6 бит адреса, остальное коды символов по 8 бит	
	banksel bufer_count
	movlw .137
	xorwf bufer_count,0
	btfss STATUS, Z
	goto not_137
	;если код длиной 137 бит, то для определения веса нас интересуют
	;биты с 98 по 137 т.к. они несут информацию о верхнем ряде символов
	;1й символ (слева) находится в битах с 130 по 137
	;2й символ (слева) находится в битах с 122 по 129
	;3й символ (слева) находится в битах с 114 по 121
	;4й символ (слева) находится в битах с 106 по 113
	;5й символ (слева) находится в битах с 98 по 105
	;т.е. нам надо сдвинуть на 1 бит влево биты в переменных LCD_bufer12-LCD_bufer16
	banksel LCD_bufer
	;определяем что это за цифры и переводим в ASCII коды цифр для последующей отправки	
	clrf koma
;	clrf koma+1
;	call recog_seg1_1 ;распознавание данных для 1го разряда 1го ряда
;	call recog_seg1_2 ;распознавание данных для 2го разряда 1го ряда
;	call recog_seg1_3 ;распознавание данных для 3го разряда 1го ряда
;	call recog_seg1_4 ;распознавание данных для 4го разряда 1го ряда
;	call recog_seg1_5 ;распознавание данных для 5го разряда 1го ряда
;	call recog_seg2_1 ;распознавание данных для 1го разряда 2го ряда
;	call recog_seg2_2 ;распознавание данных для 2го разряда 2го ряда
;	call recog_seg2_3 ;распознавание данных для 3го разряда 2го ряда
;	call recog_seg2_4 ;распознавание данных для 4го разряда 2го ряда
;	call recog_seg2_5 ;распознавание данных для 5го разряда 2го ряда
;	call recog_seg3_1 ;распознавание данных для 1го разряда 3го ряда
;	call recog_seg3_2 ;распознавание данных для 2го разряда 3го ряда
;	call recog_seg3_3 ;распознавание данных для 3го разряда 3го ряда
;	call recog_seg3_4 ;распознавание данных для 4го разряда 3го ряда
;	call recog_seg3_5 ;распознавание данных для 5го разряда 3го ряда
;	call recog_seg3_6 ;распознавание данных для 6го разряда 3го ряда
;	call recog_bat;распознаем заряд аккумулятора
	return
not_137
	;если код меньшей длины нас интересуют символы загруженные 
	;в адреса с 22 по 30 с шагом 2
	;если адрес пакета и его длина не подразумевает наличие 
	;этого диапазона этот пакет нам не интересен (изменения в вес мы не вносим)
	;bufer_count

	return


	end
